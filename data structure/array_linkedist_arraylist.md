# Linked List

연속적인 메모리 위치에 저장되지 않는 선형 데이터 구조
포인터를 사용해서 연결된다.

각 노드는 **데이터 필드** 와 **다음 노드에 대한 참조** 를 포함하는 노드로 구성된다.

## Linked List 장점

배열은 비슷한 유형의 선형 데이터를 저장하는데 사용할 수 있지만 아래와 같은 제한 사항이 있다.

1. 배열의 크기가 고정되어 있어 미리 요소의 수에 대해 할당을 받아야 한다.

2. 새로운 요소를 삽입하는 것은 비용이 많이 든다.(공간을 만들고, 기존 요소 전부 이동)

**Liked List 장점**

1. **동적 크기**

2. **삽입/삭제 용이**

**Liked List 단점**

1. 임의로 액세스를 허용할 수 없다. 즉, 첫번째 노드부터 순차적으로 요소에 액세스해야 한다.(이진 검색 수행 불가능)

2. 포인터의 여분의 메모리 공간이 목록의 각 요소에 필요하다.

노드 구현은 아래와 같이 데이터와 다음 노드에 대한 참조로 나타낼 수 있다.

```
// A linked list node
struct Node
{
  int data;
  struct Node *next;
};
```

# Array vs ArrayList vs LikedList

- Array : index로 빠르게 값을 찾는 것이 가능하다.
- LinkedList : 데이터의 삽입 삭제가 빠르다.
- ArrayList : 데이터를 찾는데 빠르지만, 삽입 및 삭제가 느리다.

### Array

배열은 선언할 때, 크기와 데이터 타입을 지정해야 한다.

**array** 는 메모리 공간에 할당할 사이즈를 미리 정해놓고 사용하는 자료구조다.

따라서, **계속 데이터가 늘어날 때, 최대 사이즈를 알 수 없을 때는 사용하기에 부적합하다.**

**또한, 중간에 데이터를 삽입하거나 삭제할 때도 매우 비효율 적이다.**

예를 들어 4번째 index 값에 새로운 값을 넣어야 한다면? 원래 값을 뒤로 밀어내고 해당 index에 덮어씌워야 한다.
기본적으로 사이즈를 정해놓은 배열에서는 해결하기엔 부적합한 점이 많다.

대신, **배열을 사용하면 index가 존재하기 때문에 위치를 바로 알 수 있어 편한 장점이 있다.**

### List

**이를 해결하기 위해 나온 것이 List다.**

List는 array처럼 크기를 정해주지 않아도 된다. 대신 array에서 index가 중요했다면, List에서는 순서가 중요하다.

크기가 정해져있지 않기 때문에, 중간에 데이터를 추가하거나 삭제하더라도 array에 갖고 있던 문제점을 해결 가능하다.

**index를 가지고 있으므로 검색도 빠르다.**

하지만, **중간에 데이터를 추가 및 삭제할 때 시간이 오래걸리는 단점이 존재한다.**
(더하거나 뺄때마다 줄줄이 당겨지거나 밀려날 때 진행되는 연산이 추가되고 메모리도 낭비된다.)

### LikedList

연결리스트에는 단일, 다중 등 여러가지가 존재한다.

종류가 무엇이든, 한 노드에 연결될 노드의 포인트 위치를 가리키는 방식으로 되어 있다.

단일은 뒤에 노드만 가리키고, 다중은 앞뒤 모두를 가리킨다.

위와 같은 방식을 활용하면서, 데이터의 중간에 삽입 및 삭제를 하더라도 전체를 돌지 않아도 이전 값과 다음 값이 가르켯던 주소값만 수정하여 연결시켜주면 되기 때문에 빠르게 진행할 수 있다.

그러나, **k번째 값을 찾아라 같은 검색에서 비효율 적이다.**

**array나 arrayList에서 index를 갖고 있기 때문에 검색이 빠르지만, LinkedList는 처음부터 살펴봐야하므로 (순차)검색에 있어서는 시간이 더 걸린다는 단점이 있다.**

javascript는 array에 list특성이 추가 돼 있다.
