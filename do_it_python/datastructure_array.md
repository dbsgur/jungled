# 자료구조와 배열

## 배열

묶음 단위로 값을 저장하는 배열

배열에는 객체가 저장되며 배열에 저장된 객체 하나하나를 element(원소)라한다.

각 원소는 index를 부여 받는다.

서로 다른 자료형을 같이 저장할 수 있다.

파이썬에서는 배열을 list 와 tuple로 구현할 수 있다.

**리스트와 튜플은 data container 라고 한다.**

리스트와 튜플의 차이점은 원소를 변경할 수 있는 지 없는지 이다.

### List

리스트는 원소를 변경할 수 있는 mutable list형 객체다.

```python
list01 = []
list02 = [1,2,3]
list03 = [1,2,3,] # 맨 마지막 원소에 쉼표 써도 된다. list03 = [1,2,3]
list04 = list()
list05 = list('abc') # ['a', 'b', 'c']
list06 = list((1,2,3,)) # [1,2,3] 튜플로부터 원소 생성
list07 = list({1,2,3}) # [1,2,3] 집합으로부터 원소 생성
```

### Tuple

튜플은 원소에 순서를 매겨 결합한 것.

**원소를 변경할 수 없는 immutable 자료형이다.**

튜플은 리스트와 다르게 결합 연산자()를 생략할 수 있다.

```python
tuple01 = () # ()
tuple02 = 1, #(1,)
tuple03 = (1,) #(1,)
tuple04 = 1,2,3 # (1,2,3)
tuple05 = 1,2,3, # (1,2,3)
```

tuple02, tuple03처럼 원소가 1개인 경우 원소 뒤에 쉼표를 꼮! 붙여줘야한다.

_쉼표가 없으면 튜플이 아니라 단순 변수로 여기기 떄문이다._

### 리스트와 튜플 풀어내기

리스트나 튜플의 원소값들ㄹ을 풀어 여러 변수에 대입하는 것을 **unpack** 이라한다.

```python
x = [1,2,3]
a,b,c = x
print(a,b,c) # (1,2,3)
```

### 인덱스로 원소에 접근하기

존재하지 않는 원소에 접근하거나 대입해도 원소가 새롭게 추가되지 않는다.

### 값 변경

값이 변경되면 값을 복사하는 것이 아니라 값을 참조하는 객체의 식별 번호가 변경되는 것이다.

```pyhton
n =5
id(n) #id() 함수로 객체의 식별 번호를 출력
# 41029409210
n = 'ABC'
id(n) #id() 함수로 객체의 고윳값을 출력
# 14029401920
```

**변수에 어떤 값을 대입하면 값이 아니라 식별 번호가 바뀐다.**

정수를 나타내는 int형과 문자열을 나타내는 str형은 값을 변경할 수 없다.
이러한 특성을 **immutable** 이라 한다.

변경할 수 있다 -> mutable

mutable 자료형 : list, dictionray, set ...이 있으며 값을 변경할 수 있다.
immutable : 수, 문자열, 튜플 등이 있으며 값을 변경할 수 없다.

## 자료구조 data structure

자료구조는 **논리적인 관계로 이루어진 데이터 구성이다. 즉, 데이터 단위와 데이터 자체 사이의 물리적 또는 논리적 관계다.**

쉽게 말해 **데이터가 모여있는 구조**

자료구조를 알아야하는 이유는 '컴퓨터에서 처리해야 하는 많은 데이터들을 모아 효율적으로 관리하고 구조화하기 위함'

### 동일성equaility과 등가성identity

equailty : '==' 값을 비교
identity : 'is' 값은 물론 객체의 식별번호가 같은지 비교

## 배열

**scan** : 배열 원소를 하나씩 차례대로 주목하여 살펴 보는 방식
스캔은 주사 또는 traverse라고 한다.

```python
list1 = [1,2,3,4,5]
list2 = [1,2,3,4,5]
list1 is list2 # False

##########################

list1 = [1,2,3,4,5]
list2 = list1
list1 is list2 # True

list[2] = 9
list1 # [1,2,9,4,5]
list2 # [1,2,9,4,5]

```

### list scan

enumerate 가 range보다 빠르다

## call by object reference

파이썬에서는 매개변수에 실제 인수가 대입된다.

파이썬에서 인수 전달은 실제 인수인 객체에 대한 참조를 값으로 전달하여 매개변수에 대입되는 방식이다.

다른 프로그래밍 언어에서는 실제 인수의 값을 매개변수에 복사하는 값에 의한 호출 _call by value_ 를 사용하거나,
실제 인수의 참조를 매개변수에 복사하여 매개변수가 실제 인수와 같아지는 참조에 의한 호출 _call by reference_ 를 사용한다.

하지만 파이썬은 위 2가지 호출의 중간적인 방식으로 참조하는 값을 전달한다.

바로 ! **call by object reference** 다.

1. 인수가 immutable 할때 : 함수 안에서 매개변수의 값을 변경하면 다른 객체를 생성하고 그 객체에 대한 차몾로 업데이트 된다.
   따라서, 매개변수의 값을 변경해도 호출하는 쪽의 **실제 인수에는 영향을 주지 않는다.**

2. 인수가 mutable 할때 : 함수 안에서 매개변수의 값을 변경하면 객체 자체를 업데이트한다.
   따라서, 매개변수의 값을 변경하면 호출하는 쪽의 **실제 인수의 값이 변경된다.**

## copy

**shallow copy (얕은 복사)**

- 객체가 갖는 멤버의 값을 새로운 객체로 복사할 떄 객체가 참조 자료형의 멤버를 포함할 경우
- 참조 값만 복사하는 방식

```python
import copy
x = [[1,2,3], [4,5,6]]
y = x.copy()
x[0][1] = 9
x # [[1,9,3], [4,5,6]]
y # [[1,9,3], [4,5,6]]
```

**deep copy (깊은 복사)**

- 참조 값 뿐만 아니라 참조하는 객체 자체를 복사한다.
- 즉, 객체가 갖는 모든 멤버(값과 참조 형식 모두)를 복사

```python
import copy
x = [[1,2,3], [4,5,6]]
y = copy.deepcopy(x)
x[0][1] = 9
x # [[1,9,3], [4,5,6]]
y # [[1,2,3], [4,5,6]]
```
